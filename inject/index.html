<!doctype html>
<html lang="en">
<head>
  <title>Avaje</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="shortcut icon" href="/images/favicon.ico">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto|Source+Sans+Pro|Ubuntu&display=swap">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/reset.css">
  <link rel="stylesheet" href="/css/site.css">
  <link rel="stylesheet" href="/css/pygments.css">
</head>
<body>

<div class="container">
  <aside id="sidenav">
    <nav class="side scroll">
<ul>
<li><a href="#overview">Overview</a>
  <ul>
    <li><a href="#jsr-330">JSR-330</a></li>
    <li><a href="#extensions">Extensions</a></li>
  </ul>
</li>
<li><a href="#dependency">Dependencies</a>
  <ul>
    <li><a href="#maven">Maven</a></li>
    <li><a href="#gradle">Gradle</a></li>
    <li><a href="#jpms">JPMS Module system</a></li>
  </ul>
</li>
<li><a href="#injection">Injection</a>
  <ul>
    <li><a href="#singleton">@Singleton</a></li>
    <li><a href="#inject">@Inject</a></li>
    <li><a href="#constructor">Constructor injection</a></li>
    <li><a href="#field">Field injection</a></li>
    <li><a href="#method">Method injection</a></li>
    <li><a href="#circular">Circular dependencies</a></li>
    <li><a href="#optional">Optional</a></li>
    <li><a href="#nullable">Nullable</a></li>
    <li><a href="#list">List and Set</a></li>
    <li><a href="#provider">Provider</a></li>
    <li><a href="#factory">@Factory</a></li>
    <li><a href="#bean">@Bean</a></li>
    <li><a href="#primary">@Primary</a></li>
    <li><a href="#secondary">@Secondary</a></li>
  </ul>
</li>
<li><a href="#qualifiers">Qualifiers</a>
  <ul>
    <li><a href="#named">@Named</a></li>
    <li><a href="#qualifier">@Qualifier</a></li>
  </ul>
</li>
<li><a href="#lifecycle">Lifecycle</a>
  <ul>
    <li><a href="#post-construct">@PostConstruct</a></li>
    <li><a href="#pre-destroy">@PreDestroy</a></li>
    <li><a href="#auto-closeable">AutoCloseable</a></li>
  </ul>
</li>
<li><a href="#scope">Scope</a>
  <ul>
    <li><a href="#scope-singleton">@Singleton</a></li>
    <li><a href="#scope-request">@Request</a></li>
    <li><a href="#controller">@Controller</a></li>
  </ul>
</li>
<li><a href="#application-scope">ApplicationScope</a>
  <ul>
    <li><a href="#application-scope">ApplicationScope</a></li>
    <li><a href="#bean-scope">BeanScope</a></li>
    <li><a href="#request-scope">RequestScope</a></li>
  </ul>
</li>
<li><a href="#testing">Testing</a>
  <ul>
    <li><a href="#unit-testing">Unit testing</a></li>
    <li><a href="#component-testing">Component testing</a></li>
  </ul>
</li>
<li><a href="#modules">Modules</a>
  <ul>
    <li><a href="#single-module">Single module</a></li>
    <li><a href="#multi-module">Multi-module</a></li>
    <li><a href="#inject-module">@InjectModule</a></li>
  </ul>
</li>
<li><a href="#why">Why avaje-inject exists?</a>
  <ul>
    <li><a href="#why-history">Short history of DI</a></li>
    <li><a href="#why-comparison">Comparison to other DI</a></li>
  </ul>
</li>
<li><a href="#http">http servers</a>
  <ul>
    <li><a href="#http-javalin">Javalin</a></li>
    <li><a href="#http-helidon">Helidon SE</a></li>
  </ul>
</li>
<li><a href="#spring">Spring DI</a>
</li>
<li><a href="#aop">AOP</a>
</li>
</ul>
<p>&nbsp;</p>
    </nav>
  </aside>
  <article id="main-content">
    
<header>
  <nav id="top">
    <div class="breadcrumb">
      <a href="/" title="home">avaje</a> &nbsp;&nbsp;/&nbsp;&nbsp;inject
    </div>
    <ul>
      <li><a href="/" title="home"><i class="fas fa-home"></i></a></li>
      <li><a href="https://github.com/avaje/avaje-inject" title="github source"><i class="fab fa-github"></i></a></li>
      <li><a onclick="toggleTheme();" title="switch dark light theme"><i class="fas fa-adjust"></i></a></li>
    </ul>
  </nav>
</header>
<h1 id="overview">Avaje Inject</h1>
<p>
  Fast and light dependency injection library for Java and Kotlin developers.
</p>
<table width="100%">
  <tr>
    <th>License</th>
    <th>Source</th>
    <th>API Docs</th>
    <th>Issues</th>
    <th>Releases</th>
  </tr>
  <tr>
    <td><a target="_blank" href="https://github.com/avaje/avaje-inject/blob/master/LICENSE">Apache2</a></td>
    <td><a target="_blank" href="https://github.com/avaje/avaje-inject">Github</a></td>
    <td><a target="_blank" href="/apidocs/avaje-inject">Javadoc</a></td>
    <td><a target="_blank" href="https://github.com/avaje/avaje-inject/issues">Github</a></td>
    <td><a target="_blank" href="https://github.com/avaje/avaje-inject/releases">Latest 6.1</a></td>
  </tr>
</table>
<p>&nbsp;</p>

<p>
  Uses Java annotation processing generating source code for dependency injection.
  That puts the work of performing dependency injection to build time rather than
  runtime increasing the speed of application start. There is no use of reflection
  or classpath scanning.
</p>
<p>
  DI is generated source code allowing developers to see how it works and we can use
  existing IDE tools to search where code is called such as constructors and lifecycle
  methods. We can add debug breakpoints into the DI code as desired and step through
  it just like it was manually written code.
</p>
<p>
  For a <a href="#why">background on why</a> <em>avaje inject</em> exists and a
  <a href="#why-comparison">quick comparison</a> with other DI libraries such as
  Dagger2, Micronaut, Quarkus and Spring goto - <a href="#why">Why</a>.
</p>

<h3 id="size">DI Library size</h3>
<table class="basic">
  <tr>
    <td>
      <p>
        Do we care about the size of a DI library? Why is dagger and avaje-inject so much
        smaller?
      </p>
      <p>
        <em>avaje-inject</em> exists with the view that it can be <em>really</em> small and
        provide JSR-330 dependency injection using source code generation. It does not include
        AOP (which can be done separately), it does not include external configuration / properties
        (we can use avaje-config or something else). It just does DI.
      </p>
    </td>
    <td>
      <img src="/images/di-lib-size.png" alt="DI library size comparison">
    </td>
  </tr>
</table>

<h3 id="prior-docs">Older documentation</h3>
<p>
  The documentation for versions prior to 6.x is available at <a href="v4">version 4.x docs</a>
</p>

<h3 id="releases">Releases for javax and jakarta</h3>
<p>
  The move of JEE to the eclipse foundation meant a change in package from <code>javax</code>
  to <code>jakarta</code> for various APIs including JSR-330 dependency injection API.
</p>
<p>
  Today we have the choice of using the <code>javax.inject</code> dependency or using the new
  <code>jakarta.inject</code> dependency.
</p>

<h4>Want to use javax.inject?</h4>
<p>
  Use <a href="https://github.com/avaje/avaje-inject/releases/tag/avaje-inject-parent-5.1">version 5.1</a> of
  avaje-inject with the dependency on <code>javax.inject</code> (maintained on javax.main branch).
</p>
<h4>Want to use jakarta.inject?</h4>
<p>
  Use <a href="https://github.com/avaje/avaje-inject/releases/tag/avaje-inject-6.1">version 6.1</a> of
  avaje-inject with the dependency on <code>jakarta.inject</code> (maintained on master branch).
</p>

<h3 id="jsr-330">Based on JSR-330</h3>
<p>
  avaje inject is based on <a href="http://javax-inject.github.io/javax-inject/api/index.html">JSR-330: Dependency
    Injection for Java</a> - <em>javax.inject / jakarta.inject</em> with some extensions similar to Spring DI.
</p>
<p>
  JSR-330 provides:
</p>
<ul>
  <li><code><a href="#singleton">@Singleton</a></code></li>
  <li><code><a href="#inject">@Inject</a></code></li>
  <li><code><a href="#named">@Named</a> and <a href="#named">@Qualifier</a></code></li>
  <li><code><a href="#scope">@Scope</a></code></li>
</ul>
<p>
  JSR 250 - Common Annotations for the Java provides:
</p>
<ul>
  <li><code><a href="#post-construct">@PostConstruct</a></code></li>
  <li><code><a href="#pre-destroy">@PreDestroy</a></code></li>
</ul>
<p>
  <code>@PostConstruct</code> and <code>@PreDestroy</code> are part of <em>Common Annotations API</em>.
  These where in JDK 8 but from JDK 9 onwards are part of JDK module <em>javax.annotation-api</em>.
</p>
<p>
  Noting that at this point neither Dagger2 or Guice support <code>@PostConstruct</code>
  and <code>@PreDestroy</code> lifecycle annotations.
</p>

<h3 id="extensions">Spring DI like extensions to JSR-330</h3>
<h4>@Factory + @Bean</h4>
<p>
  In addition to the JSR-330 standard we use <a href="#factory">@Factory</a> + <a href="#bean">@Bean</a>
  which work the same as Spring DI's <em>@Configuration + @Bean</em> and also Micronaut's
  <em>@Factory + @Bean</em>. This is also similar to a Guice module with <em>@Provides</em> methods.
</p>
<p>
  Teams will often use <em>@Factory@Bean</em> to provide dependencies that
  are best created programmatically. Typically these depend on external configuration,
  environment settings etc.
</p>
<p>
  Factory provides a more convenient alternative to the JSR-330
  <a href="#provider">javax.inject.Provider&lt;T&gt;</a> interface and is also more natural
  for people who familiar with Spring DI or Micronaut DI.
</p>

<h4>@Primary @Secondary</h4>
<p>
  Additionally we use <a href="#primary">@Primary</a> <a href="#secondary">@Secondary</a> annotations
  which work the same as Spring DI's <em>@Primary @Secondary</em> and also Micronaut DI's
  <em>@Primary @Secondary</em>. These provide injection priority in the case when multiple injection
  candidates are available.
</p>
<h2 id="dependency">Dependencies</h2>

<h3 id="maven">Maven</h3>
<p>
  See the basic example at:
  <a href="https://github.com/dinject/examples/blob/master/basic-di/pom.xml">examples/basic-di/pom.xml</a>
</p>
<p>
  Add <em>avaje-inject</em> as a dependency.
</p>
<div class="syntax xml"><div class="highlight"><pre><span></span><span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>io.avaje<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>avaje-inject<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>6.1<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</pre></div>
</div>
<p>
  Add <em>avaje-inject-generator</em> annotation processor as a dependency with
  <em>provided scope</em>.
</p>

<div class="syntax xml"><div class="highlight"><pre><span></span><span class="c">&lt;!-- Annotation processor --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>io.avaje<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>avaje-inject-generator<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>6.1<span class="nt">&lt;/version&gt;</span>
  <span class="nt">&lt;scope&gt;</span>provided<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</pre></div>
</div>
<p>
  Note that if there are other annotation processors and they are specified via
  <em>maven-compiler-plugin</em> <em>annotationProcessorPaths</em>
  then we add <em>avaje-inject-generator</em> there instead.
</p>
<div class="syntax xml"><div class="highlight"><pre><span></span><span class="nt">&lt;plugin&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;configuration&gt;</span>
    <span class="nt">&lt;annotationProcessorPaths&gt;</span> <span class="c">&lt;!-- All annotation processors specified here --&gt;</span>
      <span class="nt">&lt;path&gt;</span>
          <span class="nt">&lt;groupId&gt;</span>io.avaje<span class="nt">&lt;/groupId&gt;</span>
          <span class="nt">&lt;artifactId&gt;</span>avaje-inject-generator<span class="nt">&lt;/artifactId&gt;</span>
          <span class="nt">&lt;version&gt;</span>6.1<span class="nt">&lt;/version&gt;</span>
      <span class="nt">&lt;/path&gt;</span>
      <span class="nt">&lt;path&gt;</span>
          ... other annotation processor ...
      <span class="nt">&lt;/path&gt;</span>
    <span class="nt">&lt;/annotationProcessorPaths&gt;</span>
  <span class="nt">&lt;/configuration&gt;</span>
<span class="nt">&lt;/plugin&gt;</span>
</pre></div>
</div>


<h3 id="gradle">Gradle</h3>
<p>
  See the example at:
  <a href="https://github.com/dinject/examples/blob/master/javalin-gradle-java-basic/build.gradle">examples/javalin-gradle-java-basic/build.gradle</a>
</p>

<h4>Gradle 5.2+</h4>
<p>
  Use Gradle version 5.2 or greater which has better support for annotation processing.
</p>
<p>
  Also review the IntelliJ IDEA Gradle settings - see below.
</p>

<h4>Dependencies</h4>
<p>
  Add <em>avaje-inject</em> as a compile dependency and <em>avaje-inject-generator</em> as
  an annotation processor.
</p>

<div class="syntax groovy"><div class="highlight"><pre><span></span><span class="n">dependencies</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="n">compile</span><span class="o">(</span><span class="s1">&#39;io.avaje:avaje-inject:6.1&#39;</span><span class="o">)</span>
  <span class="n">annotationProcessor</span><span class="o">(</span><span class="s1">&#39;io.avaje:avaje-inject-generator:6.1&#39;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>

<h4>Kotlin KAPT</h4>
<p>
  See example at: https://github.com/dinject/examples/blob/master/basic-di-kotlin-maven/pom.xml
</p>
<p>
  For use with Kotlin we register <em>avaje-inject-generator</em> as a <code>kapt</code> processor
  to the Kotlin compiler rather than <em>annotationProcessor</em>.
</p>
<div class="syntax groovy"><div class="highlight"><pre><span></span><span class="n">dependencies</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="n">compile</span><span class="o">(</span><span class="s1">&#39;io.avaje:avaje-inject:6.1&#39;</span><span class="o">)</span>
  <span class="n">kapt</span><span class="o">(</span><span class="s1">&#39;io.avaje:avaje-inject-generator:6.1&#39;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>

<h3 id="idea">IntelliJ IDEA with Gradle</h3>
<p>
  We want to delegate the <code>build</code> to Gradle (to properly include the annotation processing)
  so check our IDEA settings.
</p>

<h4>Settings / Build / Compiler / Annotation processors</h4>
<p>
  Ensure that <code>Enable annotation processing</code> is disabled so
  that the build is delegated to Gradle (including the annotation processing):
</p>

<img src="/images/gradle-idea-disable-apt.png" width="100%">

<h5>Settings / Build / Build tools / Gradle</h5>
<p>
  Make sure <code>Build and run</code> is delegated to Gradle.
</p>
<p>
  Optionally set <em>Run tests using</em> to <code>Gradle</code> but leaving it to IntelliJ IDEA should be ok.
</p>

<img src="/images/gradle-idea-build.png" width="100%">


<h3 id="jpms">JPMS - Java module system</h3>
<p>
  <em>avaje-inject</em> supports the java module system. Add a <em>requires</em> clause and
  <em>provides</em> clause like the following:
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">org</span><span class="o">.</span><span class="na">example</span> <span class="o">{</span>

  <span class="n">requires</span> <span class="n">io</span><span class="o">.</span><span class="na field">avaje</span><span class="o">.</span><span class="na">inject</span><span class="o">;</span>

  <span class="c1">// explicitly register the generated BeanScopeFactory</span>
  <span class="n">provides</span> <span class="n">io</span><span class="o">.</span><span class="na field">avaje</span><span class="o">.</span><span class="na field">inject</span><span class="o">.</span><span class="na field">spi</span><span class="o">.</span><span class="na">BeanScopeFactory</span> <span class="n">with</span> <span class="n">org</span><span class="o">.</span><span class="na field">example</span><span class="o">.</span><span class="na">_DI&#36;BeanScopeFactory</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  With JPMS we need to explicitly specify the generated <code>BeanScopeFactory</code>
  in a <code>provides</code> clause.
</p>
<h2 id="injection">Injection</h2>

<h3 id="singleton">@Singleton</h3>
<p>
  Put <code>@Singleton</code> on beans that we want dependency injection on.
  These are beans that are created ("wired") by dependency injection and put into the scope.
  They are then available to be injected into other beans.
</p>
<h5>Spring DI Note</h5>
<p>
  Spring <code>@Component</code>, <code>@Service</code> and <code>@Repository</code> are all
  singleton scoped. With avaje-inject these would map to <code>@Singleton</code>.
</p>

<h3 id="inject">@Inject</h3>
<p>
  Put <code>@Inject</code> on the constructor that should be used for constructor dependency injection.
  Note that if there is <code>only one constructor</code> we don't need to put the <code>@Inject</code> on it.
</p>
<p>
  If we want to use field injection put the <code>@Inject</code> on the field. Note that the field must not
  be <code>private</code> and must not be <code>final</code> for field injection.
</p>

<h3 id="constructor">Constructor injection</h3>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Pump</span> <span class="n">pump</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Grinder</span> <span class="n">grinder</span><span class="o">;</span>

  <span class="nd">@Inject</span>
  <span class="kd">public</span> <span class="nf">CoffeeMaker</span><span class="o">(</span><span class="n">Pump</span> <span class="n">pump</span><span class="o">,</span> <span class="n">Grinder</span> <span class="n">grinder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">pump</span> <span class="o">=</span> <span class="n">pump</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">grinder</span> <span class="o">=</span> <span class="n">grinder</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>
  The above CoffeeMaker is using constructor injection. Both a Pump and Ginder will be injected into the
  constructor when the DI creates (or "wires") the CoffeeMaker.
</p>
<p>
  If there is only 1 constructor it is used for dependency injection and we don't need
  to specify <code>@Inject</code>.
</p>
<p>
  In general we do not expect to see logic in constructors as this typically makes it
  more difficult to write tests. If we see logic in a constructor then it is likely that we
  should try and move that logic to a <a href="#factory">Factory</a> method instead.
</p>

<h4>Kotlin constructor</h4>
<p>
  With Kotlin we frequently will not specify <em>@Inject</em> with only one constructor.
  The CoffeeMaker constructor injection then looks like:
</p>
<div class="syntax kotlin"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="k">class</span> <span class="nc">CoffeeMaker</span><span class="p">(</span><span class="k">private</span> <span class="k">val</span> <span class="py">pump</span><span class="p">:</span> <span class="n">Pump</span> <span class="p">,</span> <span class="k">private</span> <span class="k">val</span> <span class="py">grinder</span><span class="p">:</span> <span class="n">Grinder</span><span class="p">)</span>  <span class="p">{</span>

  <span class="k">fun</span> <span class="nf">makeCoffee</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>

<h3 id="field">Field injection</h3>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>

  <span class="nd">@Inject</span>
  <span class="n">Pump</span> <span class="n">pump</span><span class="o">;</span>

  <span class="nd">@Inject</span>
  <span class="n">Grinder</span> <span class="n">grinder</span><span class="o">;</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>
  With field injection the <code>@Inject</code> is placed on the field and the field must not be <code>private</code>
  and it must not be <code>final</code>.
</p>
<h4>Constructor injection preferred</h4>
<p>
  Generally there is a preference to use constructor injection over field injection as constructor
  injection:
</p>
<ul>
  <li>Promotes immutability / use of final fields / proper initialisation</li>
  <li>Communicates required dependencies at compile time. Helps when dependencies
    change to keep test code in line.</li>
  <li>Helps identify when there are too many dependencies. Too many constructor
    arguments is a more obvious code smell compared to field injection.
    Promotes single responsibility principal.</li>
</ul>

<h4>Field injection for circular dependencies</h4>
<p>
  We use field injection to handle <a href="#circular">circular dependencies</a>.
  See <a href="#circular">below</a> for more details.
</p>

<h4>Kotlin field injection</h4>
<p>
  For Kotlin we can consider using <em>lateinit</em> on the property with field injection.
</p>
<div class="syntax kotlin"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="k">class</span> <span class="nc">Grinder</span> <span class="p">{</span>

  <span class="nd">@Inject</span>
  <span class="k">lateinit</span> <span class="k">var</span> <span class="py">pump</span><span class="p">:</span> <span class="n">Pump</span>

  <span class="k">fun</span> <span class="nf">grind</span><span class="p">():</span> <span class="n">String</span> <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>

<h3 id="method">Method injection</h3>
<p>
  For method injection annotate the method with <code>@Inject</code>.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>

  <span class="n">Grinder</span> <span class="n">grinder</span><span class="o">;</span>

  <span class="nd">@Inject</span>
  <span class="kt">void</span> <span class="nf">setGrinder</span><span class="o">(</span><span class="n">Grinder</span> <span class="n">grinder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">grinder</span> <span class="o">=</span> <span class="n">grinder</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="o">...</span>
</pre></div>
</div>


<h3 id="mixed">Mixed constructor, field and method injection</h3>
<p>
  We are allowed to mix constructor, field and method injection. In the below example the Grinder
  is injected into the constructor and the Pump is injected by field injection.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>

  <span class="nd">@Inject</span>
  <span class="n">Pump</span> <span class="n">pump</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Grinder</span> <span class="n">grinder</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">CoffeeMaker</span><span class="o">(</span><span class="n">Grinder</span> <span class="n">grinder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">grinder</span> <span class="o">=</span> <span class="n">grinder</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>
</div>

<h3 id="circular">Circular dependencies</h3>
<p>
  When we have a circular dependency then we need to use <a href="#field">field injection</a>
  on one of the dependencies.
</p>
<p>
  For example, lets say we have A and B where A depends on B and B depends on A. In this case
  we can't use constructor injection for both A and B like:
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// circular dependency with constructor injection, this will not work !!</span>

<span class="nd">@Singleton</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
  <span class="n">B</span> <span class="n">b</span><span class="o">;</span>
  <span class="n">A</span><span class="o">(</span><span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>       <span class="c1">// constructor for A depends on B</span>
    <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Singleton</span>
<span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
  <span class="n">A</span> <span class="n">a</span><span class="o">;</span>
  <span class="n">B</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>       <span class="c1">// constructor for B depends on A</span>
    <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  With the above circular dependencies for A and B constructor injection <em>avaje-inject</em>
  can not determine the order in which to construct the beans. <em>avaje-inject</em> will
  detect this and product a compilation error outlining the beans involved and ask us
  to change to use field injection for one of the dependencies.
</p>
<p>
  We can not use constructor injection for both A and B and instead we must use
  field injection on either A or B like:
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
  <span class="nd">@Inject</span>   <span class="c1">// use field injection</span>
  <span class="n">B</span> <span class="n">b</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Singleton</span>
<span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
  <span class="n">A</span> <span class="n">a</span><span class="o">;</span>
  <span class="n">B</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  The reason this works is that field injection occurs later after all the
  dependencies are constructed. <em>avaje-inject</em> uses 2 phases to
  "wire" the beans and then a 3rd phase to execute the <code>@PostConstruct</code>
  lifecycle methods:
</p>
<ul>
  <li>Phase 1: Construct all the beans in order based on constructor dependencies</li>
  <li>Phase 2: Apply field injection on all beans</li>
  <li>Phase 3: Execute all <code>@PostConstruct</code> lifecycle methods</li>
</ul>
<p>
  Circular dependencies more commonly occur with more than 2 beans. For example,
  lets say we have A, B and C where:
</p>
<ul>
  <li>A depends on B</li>
  <li>B depends on C</li>
  <li>C depends on A</li>
</ul>
<p>
  With A, B, C above they combine to create a circular dependency. To handle this
  we need to use <a href="#field">field injection</a> on one of the dependencies.
</p>

<h3 id="optional">Optional</h3>
<p>
  We can use <code>java.util.Optional&lt;T&gt;</code> to inject optional dependencies.
  These are dependencies that might not be provided / might not have an available implementation
  / might only be provided based on configuration (a bit like a feature toggle).
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">class</span> <span class="nc">Pump</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Heater</span> <span class="n">heater</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">widget</span><span class="o">;</span>

  <span class="nd">@Inject</span>
  <span class="n">Pump</span><span class="o">(</span><span class="n">Heater</span> <span class="n">heater</span><span class="o">,</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">widget</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">heater</span> <span class="o">=</span> <span class="n">heater</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">widget</span> <span class="o">=</span> <span class="n">widget</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">pump</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">widget</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">widget</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">doStuff</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<h5>Spring DI Note</h5>
<p>
  Spring users will be familiar with the use of <code>@Autowired(required=false)</code>
  for wiring optional dependencies. With <em>avaje-inject</em> we instead use <code>Optional</code>
  or <code>@Nullable</code> to inject optional dependencies.
</p>

<h3 id="nullable">@Nullable</h3>
<p>
  As an alternative to Optional we can use <code>@Nullable</code> to indicate that a dependency
  is optional / can be null. Any <code>@Nullable</code> annotation can be used, it does not
  matter which package the annotation is in.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">class</span> <span class="nc">Pump</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Heater</span> <span class="n">heater</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Widget</span> <span class="n">widget</span><span class="o">;</span>

  <span class="nd">@Inject</span>
  <span class="nx">Pump</span><span class="o">(</span><span class="nx">Heater</span> <span class="nx">heater</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nx">Widget</span> <span class="nx">widget</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">heater</span> <span class="o">=</span> <span class="n">heater</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">widget</span> <span class="o">=</span> <span class="n">widget</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">pump</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">widget</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">widget</span><span class="o">.</span><span class="na">doStuff</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<h3 id="list">List</h3>
<p>
  We can inject a <code>java.util.List&lt;T&gt;</code> of beans that implement an interface.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CombinedBars</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">bars</span><span class="o">;</span>

  <span class="nd">@Inject</span>
  <span class="kd">public</span> <span class="nf">CombinedBars</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">bars</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">bars</span> <span class="o">=</span> <span class="n">bars</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>
</div>

<h3 id="set">Set</h3>
<p>
  We can inject a <code>java.util.Set&lt;T&gt;</code> of beans that implement an interface.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CombinedBars</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">bars</span><span class="o">;</span>

  <span class="nd">@Inject</span>
  <span class="kd">public</span> <span class="nf">CombinedBars</span><span class="o">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">bars</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">bars</span> <span class="o">=</span> <span class="n">bars</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>
</div>

<h3 id="provider">Provider</h3>
<p>
  A Singleton bean can implement <code>javax.inject.Provider&lt;T&gt;</code> to create a bean to
  be used in injection.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FooProvider</span> <span class="kd">implements</span> <span class="n">Provider</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Bazz</span> <span class="n">bazz</span><span class="o">;</span>

  <span class="n">FooProvider</span><span class="o">(</span><span class="n">Bazz</span> <span class="n">bazz</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">bazz</span> <span class="o">=</span> <span class="n">bazz</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Foo</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// maybe do interesting logic, read environment variables ...</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">BasicFoo</span><span class="o">(</span><span class="n">bazz</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  Note that the alternative to using the <code>javax.inject.Provider&lt;T&gt;</code> interface is
  to instead use <code><a href="#factory">@Factory</a></code> and <code><a href="#bean">@Bean</a></code>
  as it is more flexible and convenient than the the provider interface.
</p>
<h5>Spring DI Note</h5>
<p>
  The JSR 330 <code>javax.inject.Provider&lt;T&gt;</code> interface is functionally the same
  as Spring DI <code>FactoryBean&lt;T&gt;</code>.
</p>


<h3 id="factory">@Factory</h3>
<p>
  Factory beans allow us to programmatically creating a bean. Often the logic is based
  on external configuration, environment variables, system properties etc.
</p>
<p>
  We annotate a class with <code>@Factory</code> to tell us that it contains methods
  that create beans. The factory class can itself have dependencies and the methods
  can also have dependencies.
</p>
<p>
  <em>@Factory</em> <em>@Bean</em> are equivalent to Spring DI <em>@Configuration</em> <em>@Bean</em>
  and Micronaut <em>@Factory</em> <em>@Bean</em>. Guice users will see this as similar to Modules with
  <em>@Provides</em> methods.
</p>

<h3 id="bean">@Bean</h3>
<p>
  We annotate methods on the factory class that create a bean with <code>@Bean</code>.
  These methods can have dependencies and will execute in the appropriate order
  depending on the dependencies they require.
</p>

<h4>Example</h4>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Factory</span>
<span class="kd">class</span> <span class="nc">Configuration</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">StartConfig</span> <span class="n">startConfig</span><span class="o">;</span>

  <span class="cm">/**</span>
<span class="cm">   * Factory can have dependencies.</span>
<span class="cm">   */</span>
  <span class="nd">@Inject</span>
  <span class="n">Configuration</span><span class="o">(</span><span class="n">StartConfig</span> <span class="n">startConfig</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">startConfig</span> <span class="o">=</span> <span class="n">startConfig</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Bean</span>
  <span class="n">Pump</span> <span class="nf">buildPump</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// maybe read System properties or environment variables</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">FastPump</span><span class="o">(...);</span>
  <span class="o">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Method with dependencies as method parameters.</span>
<span class="cm">   */</span>
  <span class="nd">@Bean</span>
  <span class="n">CoffeeMaker</span> <span class="nf">buildBar</span><span class="o">(</span><span class="n">Pump</span> <span class="n">pump</span><span class="o">,</span> <span class="n">Grinder</span> <span class="n">grinder</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// maybe read System properties or environment variables</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">CoffeeMaker</span><span class="o">(...);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<h3 id="initMethod">@Bean initMethod & destroyMethod</h3>
<p>
  With <code>@Bean</code> we can specify an <code>initMethod</code>
  which will be executed on startup like <code>@PostConstruct</code>.
  Similarly a <code>destroyMethod</code> which execute on shutdown like <code>@PreDestroy</code>.
</p>


<h4>Example</h4>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Factory</span>
<span class="kd">class</span> <span class="nc">Configuration</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="nd">@Bean</span><span class="o">(</span><span class="nx">initMethod</span> <span class="o">=</span> <span class="s">&quot;init&quot;</span><span class="o">,</span> <span class="nx">destroyMethod</span> <span class="o">=</span> <span class="s">&quot;close&quot;</span><span class="o">)</span>
  <span class="n">CoffeeMaker</span> <span class="nf">buildCoffeeMaker</span><span class="o">(</span><span class="n">Pump</span> <span class="n">pump</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">CoffeeMaker</span><span class="o">(</span><span class="n">pump</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  The CoffeeMaker has the appropriate methods that are executed as part of the lifecycle.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>

  <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// lifecycle executed on start/PostConstruct</span>
  <span class="o">}</span>
  <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// lifecycle executed on shutdown/PreDestroy</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>
<h3 id="optionalBean">Optional @Bean</h3>
<p>
  We can use <code>Optional&lt;T&gt;</code> to indicate that the method produces
  an optional dependency.
</p>
<p>
  Often the dependency is only provided based on external configuration
  a bit like a feature toggle / config toggle. For example, we might do
  this in a CI/CD environment until such time that the dependency is
  always "ON" in all environments and then we change to make the dependency
  not optional.
</p>

<h4>Example - Optional dependency</h4>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Factory</span>
<span class="kd">class</span> <span class="nc">Configuration</span> <span class="o">{</span>

  <span class="cm">/**</span>
<span class="cm">   * Optionally provide MessageQueue.</span>
<span class="cm">   */</span>
  <span class="nd">@Bean</span>
  <span class="n">Optional</span><span class="o">&lt;</span><span class="n">MessageQueue</span><span class="o">&gt;</span> <span class="nf">buildQueue</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(...)</span> <span class="o">{</span> <span class="c1">// maybe read external config etc</span>
      <span class="c1">// Not providing the dependency (kind of like feature toggle)</span>
      <span class="k">return</span> <span class="n">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(...);</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>
<h3 id="useOfFactory">Use of @Factory @Bean</h3>
<p>
  It is good to use <code>@Factory</code> for all the dependencies we want to
  create programmatically. Many teams will have a standard location/package they use to
  put a "configuration factory bean" where all programmatically created dependencies are
  defined as a general approach.
</p>
<p>
  If we see logic in constructors then we typically would try to move that logic to a
  factory bean method and keep the constructors simple. Logic in constructors typically
  makes it harder from a testing perspective.
</p>

<h2 id="primary">@Primary</h2>
<p>
  A bean with <code>@Primary</code> is deemed to be highest priority and will be injected and used
  when it is available. This is functionally the same as Spring and Micronaut <em>@Primary</em>.
</p>
<p>
  There should only ever be <b>one</b> bean implementation marked as <em>@Primary</em> for
  a given dependency.
</p>

<h4>Example</h4>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// Highest priority EmailServer</span>
<span class="c1">// Used when available (e.g. module in the class path)</span>
<span class="nd">@Primary</span>
<span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PreferredEmailSender</span> <span class="kd">implements</span> <span class="n">EmailServer</span> <span class="o">{</span>
  <span class="o">...</span>
</pre></div>
</div>

<h2 id="secondary">@Secondary</h2>
<p>
  A bean with <code>@Secondary</code> is deemed to be lowest priority and will only be injected
  if there are no other candidates to inject. We use <code>@Secondary</code> to indicate a
  "default" or "fallback" implementation that will be superseded by any other available implementation.
</p>
<p>
  This is functionally the same as Spring and Micronaut <em>@Secondary</em>.
</p>
<h4>Example</h4>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// Lowest priority EmailServer</span>
<span class="c1">// Only used if no other EmailServer is available</span>
<span class="nd">@Secondary</span>
<span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultEmailSender</span> <span class="kd">implements</span> <span class="n">EmailServer</span> <span class="o">{</span>
  <span class="o">...</span>
</pre></div>
</div>

<h3 id="primary-usage">Use of @Primary and @Secondary</h3>
<p>
  <code>@Primary</code> and <code>@Secondary</code> are used when there are
  multiple candidates to inject. They provide a "priority" to determine which dependency to
  inject and use when injecting a single implementation and multiple candidates are available
  to inject.
</p>
<p>
  We typically use <em>@Primary</em> and <em>@Secondary</em> when we are
  building multi-module applications. We have multiple modules (jars) that provide implementations.
  We use <em>@Secondary</em> to indicate a "default" or "fallback" implementation to use
  and we use <em>@Primary</em> to indicate the best implementation to use when it is available.
  <em>avaje-inject</em> DI will then wire depending on which modules (jars) are included in the classpath.
</p>
<h2 id="qualifiers">Qualifiers</h2>

<h3 id="named">@Named</h3>
<p>
  When we have multiple beans that implement a common interface and we can qualify
  which instance is used by specifying <code>@Named</code> on the beans and where
  they are injected.
</p>
<p>
  Note that qualifier names are treated as case insensitive.
</p>
<p>
  Lets say we have a Store interface with multiple implementations. We can have
  multiple implementations with <em>@Named</em> qualifier like the example below.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Named</span><span class="o">(</span><span class="s">&quot;blue&quot;</span><span class="o">)</span>
<span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BlueStore</span> <span class="kd">implements</span> <span class="n">Store</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>


<span class="nd">@Named</span><span class="o">(</span><span class="s">&quot;red&quot;</span><span class="o">)</span>
<span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedStore</span> <span class="kd">implements</span> <span class="n">Store</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>

<p>
  Alternatively if we are creating the instances using <em>@Factory</em> <em>@Bean</em> methods
  we can similarly put <em>@Named</em> on the <em>@Bean</em> methods.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Factory</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StoreFactory</span> <span class="o">{</span>

  <span class="nd">@Bean</span> <span class="nd">@Named</span><span class="o">(</span><span class="s">&quot;red&quot;</span><span class="o">)</span>
  <span class="kd">public</span> <span class="n">Store</span> <span class="nf">createRedStore</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">RedStore</span><span class="o">(...);</span>
  <span class="o">}</span>

  <span class="nd">@Bean</span> <span class="nd">@Named</span><span class="o">(</span><span class="s">&quot;blue&quot;</span><span class="o">)</span>
  <span class="kd">public</span> <span class="n">Store</span> <span class="nf">createBlueStore</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">BlueStore</span><span class="o">(...);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<p>
  We can then specify which <em>@Named</em> instance to inject by specifying the qualifier.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderProcessor</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Store</span> <span class="n">store</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">OrderProcessor</span><span class="o">(</span><span class="nd">@Named</span><span class="o">(</span><span class="s">&quot;red&quot;</span><span class="o">)</span> <span class="nx">Store</span> <span class="nx">store</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">store</span> <span class="o">=</span> <span class="n">store</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="o">...</span>
</pre></div>
</div>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderProcessor</span> <span class="o">{</span>

  <span class="nd">@Inject</span> <span class="nd">@Named</span><span class="o">(</span><span class="s">&quot;red&quot;</span><span class="o">)</span>  <span class="c1">// field injection</span>
  <span class="n">Store</span> <span class="n">store</span><span class="o">;</span>

  <span class="o">...</span>
</pre></div>
</div>

<h3 id="qualifier">@Qualifier</h3>
<p>
  Instead of using <em>@Named</em> we can create our own annotations using <code>@Qualifier</code>.
  This gives a strongly typed approach to qualifying the beans rather than using string literals in
  <em>@Named</em> so could be better when there is a lot of named/qualified beans.
</p>
<h5>example</h5>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">javax.inject.Qualifier</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.annotation.Retention</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.annotation.RetentionPolicy</span><span class="o">;</span>

<span class="nd">@Qualifier</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nx">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nx">Blue</span> <span class="o">{}</span>
</pre></div>
</div>
<p>
  Then we can use our <em>@Blue</em> annotation.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Blue</span>
<span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BlueStore</span> <span class="kd">implements</span> <span class="n">Store</span> <span class="o">{</span>
  <span class="o">...</span>
</pre></div>
</div>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StoreManager</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Store</span> <span class="n">store</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">StoreManager</span><span class="o">(</span><span class="nd">@Blue</span> <span class="nx">Store</span> <span class="nx">store</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">store</span> <span class="o">=</span> <span class="n">store</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="o">...</span>
</pre></div>
</div>
<h2 id="lifecycle">Lifecycle</h2>

<h3 id="post-construct">@PostConstruct</h3>
<p>
  Put <code>@PostConstruct</code> on a method that we want to run on startup just after all the
  beans have been wired.
</p>
<p>
  Typically we open a resource like network connections to a remote resource (cache, queue, database etc).
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>

  <span class="nd">@PostConstruct</span>
  <span class="kt">void</span> <span class="nf">onStartup</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// connect to remote resource ...</span>
    <span class="o">...</span>
  <span class="o">}</span>
  <span class="o">...</span>
</pre></div>
</div>

<h3 id="pre-destroy">@PreDestroy</h3>
<p>
  Put <code>@PreDestroy</code> on a method that we want to run on shutdown.
</p>
<p>
  Typically we want this method to close resources.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeMaker</span> <span class="o">{</span>

  <span class="nd">@PreDestroy</span>
  <span class="kt">void</span> <span class="nf">onShutdown</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// close resources</span>
    <span class="o">...</span>
  <span class="o">}</span>
  <span class="o">...</span>
</pre></div>
</div>

<h3 id="auto-closeable">AutoCloseable and Closeable</h3>
<p>
  Both <code>java.lang.AutoCloseable</code> and <code>java.io.Closeable</code> are treated as <em>PreDestroy</em>
  lifecycle methods. Types that implement these interfaces do not need to annotate the <code>close()</code> method,
  it will automatically be treated as if it had a <code>@PreDestroy</code> and executed when the bean scope is closed.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeQueue</span> <span class="kd">implements</span> <span class="n">AutoCloseable</span> <span class="o">{</span>

  <span class="cm">/**</span>
<span class="cm">   * Automatically treated as a PreDestroy method.</span>
<span class="cm">   */</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// close resources</span>
    <span class="o">...</span>
  <span class="o">}</span>
  <span class="o">...</span>
</pre></div>
</div>

<h3 id="shutdownHook">Shutdown hook</h3>
<p>
  When the <a href="#scope-application">ApplicationScope</a> is initialised it registers a JVM shutdown hook.
  This is fired when the JVM is shutdown and this in turn invokes the PreDestroy methods.
</p>
<h2 id="scope">Scope</h2>

<h3 id="scope-singleton">@Singleton</h3>
<p>
  Beans annotated with <code>@Singleton</code> will have a single instance created
  in the BeanScope. For an application we typically only have one BeanScope (ApplicationScope)
  and so we only create one instance.
</p>
<p>
  Singleton's can only depend on other singleton beans. If we add a dependency to a <code>@Request</code>
  bean then we will get a compiler error telling us we can't do that.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductService</span>  <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>

<h3 id="scope-request">@Request</h3>
<p>
  Beans annotated with <code>@Request</code> have request scope. This means that:
</p>
<ul>
  <li>They can only be accessed via RequestScope</li>
  <li>They can depend on things supplied to the RequestScope</li>
  <li>They can depend on other @Request beans</li>
  <li>They can depend on @Singleton beans</li>
</ul>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Request</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductController</span> <span class="o">{</span>

  <span class="cm">/**</span>
<span class="cm">   * Can depend on:</span>
<span class="cm">   * - Things provided to the request scope</span>
<span class="cm">   * - @Request scope beans</span>
<span class="cm">   * - @Singleton beans</span>
<span class="cm">   */</span>
  <span class="kd">public</span> <span class="nf">ProductController</span><span class="o">(</span><span class="n">HttpRequest</span> <span class="n">request</span><span class="o">,</span> <span class="n">HttpResponse</span> <span class="n">response</span><span class="o">,</span> <span class="n">ProductService</span> <span class="n">productService</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>

<p>
  We can only use request scoped beans via <em>RequestScope</em>. One instance is created once per
  <code>RequestScope</code> on demand - an instance is only created if it is used for that request.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="k">try</span> <span class="o">(</span><span class="n">RequestScope</span> <span class="n">requestScope</span> <span class="o">=</span> <span class="n">ApplicationScope</span><span class="o">.</span><span class="na">newRequestScope</span><span class="o">()</span>
  <span class="o">.</span><span class="na">withBean</span><span class="o">(</span><span class="n">HttpRequest</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">request</span><span class="o">)</span>
  <span class="o">.</span><span class="na">withBean</span><span class="o">(</span><span class="n">HttpResponse</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">response</span><span class="o">)</span>
  <span class="o">.</span><span class="na">build</span><span class="o">())</span> <span class="o">{</span>

  <span class="n">ProductController</span> <span class="n">productController</span> <span class="o">=</span> <span class="n">requestScope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ProductController</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="n">productController</span><span class="o">.</span><span class="na">doStuff</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>

<h3 id="controller">@Controller (avaje-http)</h3>
<p>
  If we are using <a href="/http">avaje-http</a> then we use
  <a href="/http/#controller">@Controller</a> rather than <code>@Singleton</code>
  or <code>@Request</code>. When we do this avaje  inject will detect if the controller
  needs to be request scoped (by looking at it's dependencies at compile time) and
  automatically handle that.
</p>
<p>
  In general we would only expect to use <code>@Request</code> and <code>RequestScope</code>
  when we are not using <em>avaje-http</em>.
</p>
<h2 id="application-scope">ApplicationScope</h2>
<p>
  <code>ApplicationScope</code> provides access to the beans in the application scope. ApplicationScope will
  initialise with a BeanScope that contains all the singleton scoped beans. All the PostConstruct methods will
  have been executed. A shutdown hook is registered and will invoke the PreDestroy methods on shutdown.
</p>
<h5>example</h5>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// Get a bean</span>
<span class="n">CoffeeMaker</span> <span class="n">coffeeMaker</span> <span class="o">=</span> <span class="n">ApplicationScope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">CoffeeMaker</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">coffeeMaker</span><span class="o">.</span><span class="na">brew</span><span class="o">();</span>
</pre></div>
</div>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// Get all the beans that implement an interface</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">WebRoutes</span><span class="o">&gt;</span> <span class="n">webRoutes</span> <span class="o">=</span> <span class="n">ApplicationScope</span><span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">WebRoutes</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="c1">// register them with Javalin</span>
<span class="n">Javalin</span> <span class="n">app</span> <span class="o">=</span> <span class="n">Javalin</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
<span class="n">app</span><span class="o">.</span><span class="na">routes</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">webRoutes</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">WebRoutes</span><span class="o">::</span><span class="n">registerRoutes</span><span class="o">));</span>
<span class="n">app</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="mi">8080</span><span class="o">);</span>
</pre></div>
</div>

<h4>ApplicationScope.scope()</h4>
<p>
  We use <em>ApplicationScope.scope()</em> to get the underlying <code>BeanScope</code>.
  We often prefer to use the BeanScope with code to start the application as this
  allows us to have tests that run the entire application with perhaps only a few
  dependencies mocked out (component testing).

  For example, run a component test that starts the application using all real
  components except for ones that make remote calls to another service  which are
  mocked/stubbed.
</p>

<h5>example</h5>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">App</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// main just uses ApplicationScope.scope()</span>
      <span class="k">new</span> <span class="n">App</span><span class="o">().</span><span class="na">startServer</span><span class="o">(</span><span class="mi">8080</span><span class="o">,</span> <span class="n">ApplicationScope</span><span class="o">.</span><span class="na">scope</span><span class="o">())</span>
  <span class="o">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Tests can create a BeanScope with some mocks, stubs.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="nf">startServer</span><span class="o">(</span><span class="kt">int</span> <span class="n">port</span><span class="o">,</span> <span class="n">BeanScope</span> <span class="n">scope</span><span class="o">)</span> <span class="o">{</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">WebRoutes</span><span class="o">&gt;</span> <span class="n">webRoutes</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">WebRoutes</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="n">Javalin</span> <span class="n">app</span> <span class="o">=</span> <span class="n">Javalin</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
    <span class="n">app</span><span class="o">.</span><span class="na">routes</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">webRoutes</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">WebRoutes</span><span class="o">::</span><span class="n">registerRoutes</span><span class="o">));</span>
    <span class="n">app</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="n">port</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>

<h3 id="bean-scope">BeanScope</h3>
<p>
  The methods on BeanScope that we use to obtain beans out of the scope are:
</p>

<h5>get(<em>type</em>)</h5>
<p>
  Return a single bean given the type.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="n">StoreManager</span> <span class="n">storeManager</span> <span class="o">=</span> <span class="n">beanScope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">StoreManager</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">StoreManager</span><span class="o">.</span><span class="na">processOrders</span><span class="o">();</span>
</pre></div>
</div>

<h5>get(<em>type</em>, <em>qualifier</em>)</h5>
<p>
  Return a single bean given the type and qualifier name.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="n">Store</span> <span class="n">blueStore</span> <span class="o">=</span> <span class="n">beanScope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Store</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">&quot;blue&quot;</span><span class="o">);</span>
<span class="n">blueStore</span><span class="o">.</span><span class="na">checkOrders</span><span class="o">();</span>
</pre></div>
</div>

<h5>list(<em>type</em>)</h5>
<p>
  Return the list of beans that implement the interface.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// e.g. register all routes for a web framework</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">WebRoute</span><span class="o">&gt;</span> <span class="n">routes</span> <span class="o">=</span> <span class="n">beanScope</span><span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">WebRoute</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</pre></div>
</div>

<h5>listByAnnotation(<em>annotation type</em>)</h5>
<p>
  Return the list of beans that have an annotation.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// e.g. register all controllers with web a framework</span>
<span class="c1">// .. where Controller is an annotation on the beans</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">controllers</span> <span class="o">=</span> <span class="n">beanScope</span><span class="o">.</span><span class="na">listByAnnotation</span><span class="o">(</span><span class="n">Controller</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</pre></div>
</div>
<p>
The classic use case for this is registering controllers or routes to
 web frameworks like Sparkjava, Javalin, Rapidoid, Helidon, Undertow etc.
</p>

<h5>listByPriority(<em>type</em>)</h5>
<p>
  Return the list of beans that implement the interface sorting by priority.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// e.g. filters that should be applied in @Priority order</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">Filter</span><span class="o">&gt;</span> <span class="n">filters</span> <span class="o">=</span> <span class="n">beanScope</span><span class="o">.</span><span class="na">listByPriority</span><span class="o">(</span><span class="n">Filter</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</pre></div>
</div>

<h4 id="context-builder">BeanScope.newBuilder()</h4>
<p>
  We can programmatically create a BeanScope with the option on providing
  some instances to use as dependencies. Most often we will do this for
  component testing providing mocks, spies etc to be wired into the beans.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// provide dependencies to be wired</span>
<span class="c1">// ... can be real things or test doubles</span>
<span class="n">MyDependency</span> <span class="n">dependency</span> <span class="o">=</span> <span class="o">...</span>

<span class="k">try</span> <span class="o">(</span><span class="n">BeanScope</span> <span class="n">scope</span> <span class="o">=</span> <span class="n">BeanScope</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
  <span class="o">.</span><span class="na">withBean</span><span class="o">(</span><span class="n">MyDependency</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">dependency</span><span class="o">)</span>
  <span class="o">...</span>
  <span class="o">.</span><span class="na">build</span><span class="o">())</span> <span class="o">{</span>

  <span class="n">CoffeeMaker</span> <span class="n">coffeeMaker</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">CoffeeMaker</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="n">coffeeMaker</span><span class="o">.</span><span class="na">makeIt</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  See <a href="#testing">Testing</a> for more on wiring with test doubles.
</p>

<h3 id="request-scope">RequestScope</h3>
<p>
  Note that if we are using <a href="/http">avaje-http</a> then we will not explicitly
  use RequestScope or <a href="#scope-request">@Request</a> - we would instead use
  <a href="/http/#controller">@Controller</a>.
</p>
<p>
  <code>RequestScope</code> is created from ApplicationScope or BeanScope.
  We provide some dependencies which can be wired into <a href="#scope-request">@Request</a>
  beans. We can obtain beans from the RequestScope to perform the required processing.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="k">try</span> <span class="o">(</span><span class="n">RequestScope</span> <span class="n">requestScope</span> <span class="o">=</span> <span class="n">ApplicationScope</span><span class="o">.</span><span class="na">newRequestScope</span><span class="o">()</span>
  <span class="o">.</span><span class="na">withBean</span><span class="o">(</span><span class="n">HttpRequest</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">request</span><span class="o">)</span>
  <span class="o">.</span><span class="na">withBean</span><span class="o">(</span><span class="n">HttpResponse</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">response</span><span class="o">)</span>
  <span class="o">.</span><span class="na">build</span><span class="o">())</span> <span class="o">{</span>

  <span class="n">requestScope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">MyRequestProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">doStuff</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  An approximate alternative to using RequestScope is to put all the request scoped
  dependencies into a new type and pass that as a method argument to singleton scoped
  things to process.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="n">MyHttpRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyHttpRequest</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>

<span class="n">ApplicationScope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">MySingletonProcessor</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">process</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
</pre></div>
</div>
<p>
  When we want request scoped things to be dependencies that are "injected" by avaje-inject
  rather than passed around via a method argument then we use RequestScope.
</p>
<h2 id="testing">Testing</h2>

<h3 id="unit-testing">Unit testing</h3>
<p>
  When we are <em>unit testing</em> we are not using avaje-inject. We are focused on the
  thing we want to test (object under test) and it's dependencies.
</p>
<p>
  With unit testing in the test setup code will create the thing we are testing (object under test)
  along with it's dependencies.
</p>

<h5>Mockito programmatic style</h5>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="c1">// setup</span>
<span class="kd">final</span> <span class="n">Pump</span> <span class="n">pump</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">Pump</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">Grinder</span> <span class="n">grinder</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">Grinder</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">CoffeeMaker</span> <span class="n">coffeeMaker</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CoffeeMaker</span><span class="o">(</span><span class="n">pump</span><span class="o">,</span> <span class="n">grinder</span><span class="o">);</span>

<span class="c1">// act</span>
<span class="n">coffeeMaker</span><span class="o">.</span><span class="na">makeIt</span><span class="o">();</span>

<span class="n">verify</span><span class="o">(</span><span class="n">pump</span><span class="o">).</span><span class="na">pumpSteam</span><span class="o">();</span>
<span class="n">verify</span><span class="o">(</span><span class="n">grinder</span><span class="o">).</span><span class="na">grindBeans</span><span class="o">();</span>
</pre></div>
</div>

<h5>Mockito junit5 extension</h5>
<p>
  Mockito provides a JUnit 5 extension <code>MockitoExtension</code> which can be used
  with JUnit <code>@ExtendWith</code>. With this extension we can annotate fields with
  <code>@Mock</code>, <code>@Spy</code> and <code>@Captor</code>. Again, this is all
  Mockito - no avaje inject is used here.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nx">MockitoExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">CoffeeMakerTest</span> <span class="o">{</span>

  <span class="nd">@Mock</span> <span class="nx">Pump</span> <span class="nx">pump</span><span class="o">;</span>
  <span class="nd">@Mock</span> <span class="nx">Grinder</span> <span class="nx">grinder</span><span class="o">;</span>

  <span class="nd">@Test</span>
  <span class="kt">void</span> <span class="nf">extensionStyle</span><span class="o">()</span> <span class="o">{</span>

    <span class="c1">// setup</span>
    <span class="n">CoffeeMaker</span> <span class="n">coffeeMaker</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CoffeeMaker</span><span class="o">(</span><span class="n">pump</span><span class="o">,</span> <span class="n">grinder</span><span class="o">);</span>

    <span class="c1">// act</span>
    <span class="n">coffeeMaker</span><span class="o">.</span><span class="na">makeIt</span><span class="o">();</span>

    <span class="n">verify</span><span class="o">(</span><span class="n">pump</span><span class="o">).</span><span class="na">pumpSteam</span><span class="o">();</span>
    <span class="n">verify</span><span class="o">(</span><span class="n">grinder</span><span class="o">).</span><span class="na">grindBeans</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  avaje-inject is NOT used in the above unit tests (as expected). We will see below that avaje-inject
  provides a JUnit extension similar to the Mockito one and that uses the Mockito annotations
  <code>@Mock, @Spy, @Captor</code> and also adds <code>@Inject</code>.
</p>

<h3 id="component-testing">Component testing</h3>
<p>
  Component testing is where we look to run tests that use most of the objects with their real
  behaviour and only a few of the objects with mocked / stubbed behaviour. With component testing
  we are looking to test a scenario / piece of functionality with minimal to no mocking.
</p>
<p>
  With avaje-inject component testing we are getting avaje-inject to "wire" most or all of
  the application with potentially some objects as test doubles (mocks, spies, stubs or dummies).
  For example, we might wire the entire application only using test doubles for objects that
  make remote calls to another system.
</p>

<h4>JUnit 5 InjectExtension</h4>
<p>
  avaje-inject provides a JUnit 5 extension <code>InjectExtension</code>. With this we use
  <code>@Inject</code> as well as mockito's <code>@Mock, @Spy, @Captor</code> to define the
  objects we wish to use in the test.
</p>
<p>
  Add <em>avaje-inject-test</em> as a test dependency.
</p>
<div class="syntax xml"><div class="highlight"><pre><span></span><span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>io.avaje<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>avaje-inject-test<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>6.1<span class="nt">&lt;/version&gt;</span>
  <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</pre></div>
</div>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nx">InjectExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">CoffeeMakerTest</span> <span class="o">{</span>

  <span class="nd">@Mock</span> <span class="nx">Pump</span> <span class="nx">pump</span><span class="o">;</span>
  <span class="nd">@Mock</span> <span class="nx">Grinder</span> <span class="nx">grinder</span><span class="o">;</span>
  <span class="nd">@Inject</span> <span class="nx">CoffeeMaker</span> <span class="nx">coffeeMaker</span><span class="o">;</span>

  <span class="nd">@Test</span>
  <span class="kt">void</span> <span class="nf">extensionStyle</span><span class="o">()</span> <span class="o">{</span>

    <span class="c1">// act</span>
    <span class="n">coffeeMaker</span><span class="o">.</span><span class="na">makeIt</span><span class="o">();</span>

    <span class="n">verify</span><span class="o">(</span><span class="n">pump</span><span class="o">).</span><span class="na">pumpSteam</span><span class="o">();</span>
    <span class="n">verify</span><span class="o">(</span><span class="n">grinder</span><span class="o">).</span><span class="na">grindBeans</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>
  With <em>InjectExtension</em> avaje-inject will build a BeanScope will the appropriate mockito
  mocks and spies and inject back into the test the appropriate objects out of the BeanScope.
</p>
<h4>@Named and @Qualifier</h4>
<p>
  We can use <code>@Named</code> and qualifiers as needed like below.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Mock</span> <span class="nd">@Blue</span> <span class="nx">Store</span> <span class="nx">blueStore</span><span class="o">;</span>

<span class="nd">@Mock</span> <span class="nd">@Named</span><span class="o">(</span><span class="s">&quot;red&quot;</span><span class="o">)</span> <span class="nx">Store</span> <span class="nx">redStore</span><span class="o">;</span>
</pre></div>
</div>

<h4>Programmatic style component test</h4>
<p>
  For programmatic style component testing we create a BeanScope and define test doubles that
  we want to use in place of the real things. We can use <code>withMock()</code> to get a
  dependency to be a Mockito mock. We can use <code>withSpy()</code> to get a dependency to
  be a Mockito spy. We can use <code>withBean()</code> to supply any sort of test double we
  like.
</p>

<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">myComponentTest</span><span class="o">()</span> <span class="o">{</span>

  <span class="k">try</span> <span class="o">(</span><span class="n">BeanScope</span> <span class="n">scope</span> <span class="o">=</span> <span class="n">BeanScope</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">withMock</span><span class="o">(</span><span class="n">Pump</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">withMock</span><span class="o">(</span><span class="n">Grinder</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">())</span> <span class="o">{</span>

    <span class="c1">// act</span>
    <span class="n">CoffeeMaker</span> <span class="n">coffeeMaker</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">CoffeeMaker</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">coffeeMaker</span><span class="o">.</span><span class="na">makeIt</span><span class="o">();</span>

    <span class="n">verify</span><span class="o">(</span><span class="n">pump</span><span class="o">).</span><span class="na">pumpSteam</span><span class="o">();</span>
    <span class="n">verify</span><span class="o">(</span><span class="n">grinder</span><span class="o">).</span><span class="na">grindBeans</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>

<h2 id="modules">Modules</h2>

<h3 id="single-module">Single module apps</h3>
<p>
  When we are wiring dependencies that are all part of a single jar/module then we don't
  really care about modules. All the dependencies that are being injected are known and
  provided by the same jar/module.
</p>
<p>
  In a single module app there is only 1 BeanScope.
</p>

<h3 id="multi-module">Multi-module apps</h3>
<p>
  When we are wiring dependencies that span multiple jars/modules then we to provide more
  control over the order in which each modules dependencies are wired. We provide this control
  by using <code>@InjectModule</code>.
</p>
<p>
  In a multi-module app there is 1 BeanScope per module and <em>avaje-inject</em> needs to
  determine the order in which the modules are wired. It does this using the module <em>provides</em>
  and <em>dependsOn</em>.
</p>

<h3 id="unnamed-module">Unnamed modules</h3>
<p>
  When we don't specify <em>@InjectModule</em> on a module it is an <em>unnamed module</em>.
  In effect a module name is derived from the top most package and that module has no
  <em>provides</em> or <em>dependsOn</em> specified.
</p>

<h3 id="context-module">@InjectModule</h3>
<p>
  Use <code>@InjectModule</code> to explicitly name a module and define the features it <em>provides</em>
  and the features it <em>dependsOn</em>. The <em>provides</em> and <em>dependsOn</em> effectively control
  the order in which modules are wired.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@InjectModule</span><span class="o">(</span><span class="nx">name</span> <span class="o">=</span> <span class="s">&quot;feature-toggle&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>
  We use the <code>@InjectModule</code> annotation to give a module an explicit name.
</p>

<h3 id="module-dependsOn">Module dependsOn</h3>
<p>
  Modules that depend on functionality / beans from other modules specify in <code>dependsOn</code>
  the modules that should provide beans they want to inject.
</p>
<div class="syntax java"><div class="highlight"><pre><span></span><span class="nd">@InjectModule</span><span class="o">(</span><span class="nx">name</span> <span class="o">=</span> <span class="s">&quot;job-system&quot;</span><span class="o">,</span> <span class="nx">dependsOn</span> <span class="o">=</span> <span class="o">{</span><span class="s">&quot;feature-toggle&quot;</span><span class="o">})</span>
</pre></div>
</div>
<p>
  With the above example the "job-system" module expects bean(s) from the "feature-toggle" module to be
  available for injecting into it's bean graph.
</p>
<p>
  For <em>avaje-inject</em> internally this defines the order in which the beans in each of the modules are created.
  <em>avaje-inject</em> finds all the modules in the classpath (via Service loader) and then orders the modules based on the
  dependsOn values. In the example above the "feature-toggle" beans must be built first, and then the
  beans it contains are available when building the "job-system".
</p>


<h2 id="why">Why avaje inject exists</h2>

<h3 id="why-history">Short History of DI on the JVM</h3>
<p>
  For a short history of DI on the JVM see below and refer to
  <a target="_blank" href="http://picocontainer.com/inversion-of-control-history.html">PicoContainer - inversion of control history</a>
</p>
<ul>
  <li>1998 - Avalon</li>
  <li>2003 - Spring and PicoContainer</li>
  <li>2005 - Guice</li>
  <li>2009 - JSR 330 javax.inject</li>
  <li>2013 - Dagger1</li>
  <li>2015 - Dagger2</li>
  <li>2018 - Micronaut</li>
  <li>2018 - Avaje-Inject (dinject)</li>
  <li>2019 - Quarkus</li>
</ul>
<p>
  Stefano Mazzocchi popularises the term, Inversion of Control and the Apache
  <a target="_blank" href="http://picocontainer.com/inversion-of-control-history.html#avalon">Avalon</a>
  project starts.
</p>
<p>
  Spring and PicoContainer lead the initial adoption of DI. Java 5 came out with
  new language features which included annotations and generics which lead to the
  creation of Guice.
</p>
<p>
  In 2009 developers from Spring, Guice, Redhat and some others got together to
  define JSR-330 - dependency injection for Java.
</p>
<p>
  Some Guice developers went on to develop Dagger which I believe was the first
  dependency injection library that used Java annotation processing to generate code
  for DI. This moves work that was previously done at runtime to build time and made
  Dagger significantly faster and lighter than Guice. Dagger becomes heavily
  adopted for Android applications.
</p>
<p>
  <em>
  Using Java annotation processing to move dependency injection work from run time
  to build time is common approach by Dagger, Micronaut, avaje-inject and Quarkus.
  </em>
</p>
<p>
  Around 2018 the pain points of using Spring DI with Kubernetes and resource limited
  containers becomes more obvious. The way Spring DI works means that at startup time it
  performs a lot of work that includes classpath scanning, heavy use of reflection and
  defining dynamic proxies.  This makes it relatively slow and hungry for both CPU and
  memory resources. With cloud deployment where we pay for CPU and memory some developers
  start looking for another approach to DI which puts more (or virtually all) of that
  work to build time using Java annotation processing [as Dagger2 had been doing in the
  Android space for some years].
</p>
<p>
  In 2018 Micronaut and <em>avaje-inject</em> (this library) are released which use
  Java annotation processing to perform most of DI at build time rather than runtime.
  In 2019 Quarkus is released which similarly uses Java annotation processing but is
  based on CDI.
</p>

<h3 id="why-comparison">Quick comparison to other DI libraries</h3>
<h5>Why not use Dagger2?</h5>
<p>
  Dagger2 is not particularly orientated for server side developers with no lifecycle
  support (@PostConstruct/@PreDestroy) and does not have some features that we like from
  Spring DI (@Factory/@Bean + @Primary/@Secondary).
</p>
<h5>Why not use Quarkus?</h5>
<p>
  Quarkus comes with a DI implementation based on CDI. If CDI is your thing you'd look
  at Quarkus.
</p>
<h5>Why not Micronaut?</h5>
<p>
  Micronaut DI and <em>avaje-inject</em> are both heavily influenced by Spring DI and
  to some extent look pretty similar. avaje-inject has taken a source code generation
  approach, excluded AOP and excluded <code>@Value</code> with a preference instead to
  use a simple <a href="/config">avaje-config</a> style approach to external configuration.
</p>
<p>
  Ultimately <em>avaje-inject</em> is a relatively tiny library in comparison to Micronaut
  DI and focused on DI alone.
</p>
<h2 id="http">http servers</h2>
<p>
  <em>avaje-inject</em> is a lightweight DI library that is especially suited to
  building http based services using <a href="https://javalin.io">Javalin</a>
  and <a href="https://helidon.io">Helidon SE</a>.
</p>
<p>
  We can build rest controllers and target either Javalin or Helidon SE using
  as little or as much of either Javalin or Helidon as we like.
</p>

<h3 id="javalin">Javalin</h3>
<p>
  Create JAX-RS style controllers targeting <a href="https://javalin.io">Javalin</a>.
  Write controller methods that take the Javalin context as a method argument or
  have it injected as a request scoped bean.
</p>
<p>
  See <a href="/http">here</a> for more details.
</p>

<h3 id="helidon">Helidon SE</h3>
<p>
  Create JAX-RS style controllers targeting <a href="https://helidon.io">Helidon SE</a>.
  Write controller methods that take the Helidon server request and/or response as
  method arguments or have them injected into the controller as request scoped beans.
</p>
<p>
  See <a href="/http">here</a> for more details.
</p>

<h2 id="spring">Spring DI</h2>

<h4>@Factory + @Bean</h4>
<p>
  <em>avaje-inject</em> has <a href="#factory">@Factory</a> + <a href="#bean">@Bean</a> which work the
  same as Spring DI's <em>@Configuration + @Bean</em> and also Micronaut's <em>@Factory + @Bean</em>.
</p>

<h4>@Primary @Secondary</h4>
<p>
  <em>avaje-inject</em> has <a href="#primary">@Primary</a> and <a href="#secondary">@Secondary</a>
  annotations which work the same as Spring DI's <em>@Primary @Secondary</em> and also Micronaut
  DI's <em>@Primary @Secondary</em>.
</p>
<p>
  These provide injection precedence in the case of injecting an implementation when multiple
  injection candidates are available.
</p>

<p>&nbsp;</p>
<h4 id="spring-translation">Spring DI translation</h4>
<table class="table">
  <tr>
    <th width="45%">Spring</th>
    <th width="45%">avaje-inject</th>
    <th width="10%">JSR-330</th>
  </tr>
  <tr>
    <td>@Component, @Service, @Repository</td>
    <td><a href="#singleton">@Singleton</a></td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>FactoryBean&lt;T&gt;</td>
    <td><a href="#provider">Provider&lt;T&gt;</a></td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>@Inject, @Autowired</td>
    <td><a href="#inject">@Inject</a></td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>@Autowired(required=false)</td>
    <td><a href="#optional">@Inject Optional&lt;T&gt;</a></td>
    <td>-</td>
  </tr>
  <tr>
    <td>@PostConstruct</td>
    <td><a href="#post-construct">@PostConstruct</a></td>
    <td>JSR 250</td>
  </tr>
  <tr>
    <td>@PreDestroy</td>
    <td><a href="#pre-destroy">@PreDestroy</a></td>
    <td>JSR 250</td>
  </tr>
  <tr>
    <td colspan="3" align="center" style="padding-top:2em;"><i>Non standard extensions to JSR-330</i></td>
  </tr>
  <tr>
    <td>@Configuration @Bean</td>
    <td><a href="#factory">@Factory @Bean</a></td>
    <td><b>No</b></td>
  </tr>
  <tr>
    <td>@Primary</td>
    <td><a href="#primary">@Primary</a></td>
    <td><b>No</b></td>
  </tr>
  <tr>
    <td>@Secondary</td>
    <td><a href="#secondary">@Secondary</a></td>
    <td><b>No</b></td>
  </tr>
</table>

<p>&nbsp;</p>
<p>&nbsp;</p>
<h4>Spring DI translation <em>NOT</em> part of avaje-inject</h4>
<table class="table">
  <tr>
    <th width="45%">Spring</th>
    <th width="45%">Other</th>
    <th width="10%"></th>
  </tr>
  <tr>
    <td>@Value</td>
    <td><a href="https://avaje.io/config/">avaje-config</a></td>
    <td></td>
  </tr>
  <tr>
    <td>@Controller</td>
    <td><a href="/http/#controller">avaje-http @Controller</a></td>
    <td></td>
  </tr>
  <tr>
    <td>@Transactional</td>
    <td><a href="https://ebean.io/docs/transactions/">Ebean @Transactional</a></td>
    <td></td>
  </tr>
</table>


<h3 id="aop">AOP</h3>
<p>
  <em>avaje-inject</em> does not include AOP as other libraries provide build time AOP
  for <code><a href="https://ebean.io/docs/transactions/">@Transactional</a></code>,
  Metrics <code><a href="https://avaje.io/metrics/">@Timed</a></code>
  and configuration injection via <a href="https://avaje.io/config/">avaje-config</a>.
</p>
<p>
  Performing AOP at build time is important as it removes the runtime cost at startup
  of using dynamic proxies.
</p>
<p>
  The following are library recommendations for @Transactional, @Value and @Timed.
</p>

<table class="table">
  <tr>
    <th width="50%">Spring</th>
    <th width="50%">Recommendation</th>
  </tr>
  <tr>
    <td>@Transactional</td>
    <td><a href="https://ebean.io/docs/transactions/">Ebean @Transactional</a></td>
  </tr>
  <tr>
    <td>@Value</td>
    <td><a href="https://avaje.io/config/">Avaje Config</a></td>
  </tr>
  <tr>
    <td>@Timed</td>
    <td><a href="https://avaje.io/metrics/">Avaje Metrics</a></td>
  </tr>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>


  </article>
</div>

<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
<script src="/js/site.js"></script>
</body>
</html>
